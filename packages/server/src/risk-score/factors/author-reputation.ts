import type { RiskContext, RiskFactor } from "../types.js";
import { getAuthorFromChallengeRequest } from "../utils.js";

/**
 * Calculate risk score based on author reputation signals.
 *
 * IMPORTANT: Trust model
 * - `author.subplebbit` fields are TRUSTED (generated by the subplebbit)
 * - All other `author.*` fields are UNTRUSTED (provided by the user, can be faked)
 *
 * We primarily rely on `author.subplebbit.lastCommentCid` for reputation signals
 * since it's verified by the subplebbit.
 *
 * Note: This is a simplified reputation check. In the future, this could
 * incorporate:
 * - Cross-subplebbit reputation
 * - Challenge completion history
 * - Moderation actions against the author
 */
export function calculateAuthorReputation(ctx: RiskContext, weight: number): RiskFactor {
    const author = getAuthorFromChallengeRequest(ctx.challengeRequest);
    const subplebbitAuthor = author.subplebbit;

    let score = 0.5; // Start neutral
    const signals: string[] = [];

    // Check for lastCommentCid from subplebbit (TRUSTED data from the sub)
    // This is the primary reputation signal as it's verified by the subplebbit
    if (subplebbitAuthor?.lastCommentCid) {
        score -= 0.2;
        signals.push("has verified comment history in this subplebbit");
    } else {
        // No verified history in this subplebbit
        score += 0.1;
        signals.push("no verified publication history in this subplebbit");
    }

    // Note: We intentionally do NOT use author.previousCommentCid as a trust signal
    // because it's user-provided and can be faked. An attacker could easily set
    // this to any CID to appear legitimate.

    // Clamp score to [0, 1]
    score = Math.max(0, Math.min(1, score));

    const explanation = signals.length > 0 ? `Author reputation: ${signals.join(", ")}` : "Author reputation: neutral (no signals)";

    return {
        name: "authorReputation",
        score,
        weight,
        explanation
    };
}
